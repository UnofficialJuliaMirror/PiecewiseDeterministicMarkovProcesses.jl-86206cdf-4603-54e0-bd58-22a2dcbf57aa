{
    "docs": [
        {
            "location": "/", 
            "text": "PDMP.jl\n\n\nPDMP.jl is a Julia package that allows simulation of \nPiecewise Deterministic Markov Processes\n (PDMP); these encompass hybrid systems and jump processes, comprised of continuous and discrete components, as well as processes with time-varying rates. The aim of the package is to provide methods for the simulation of these processes that are \"exact\" up to the ODE integrator.\n\n\nWe provide several methods for the simulation:\n\n\n\n\na recent trick, called \nCHV\n, explained in \npaper-2015\n which allows to implement the \nTrue Jump Method\n without the need to use event detection schemes for the ODE integrator. These event detections can be quite unstable as explained in \npaper-2015\n and CHV provide a solution to this problem.\n\n\nrejection methods\n for which the user is asked to provide a bound on the reaction rates. These last methods are the most \"exact\" but not the fastest if the reaction rate bound is not tight. In case the flow is known analytically, a method is also provided.\n\n\n\n\nThese methods require solving stiff ODEs (for CHV ) in an efficient manner. \nSundials.jl\n and \nLSODA.jl\n are used, but other solvers could be easily added. (See \nstiff ode solvers\n).\n\n\nWe briefly recall facts about a simple class of PDMPs. They are described by a couple $(x_c,x_d)$ where $x_c$ is solution of the differential equation $\\frac{dx_c}{dt} = F(x_c,x_d,t)$. The second component $x_d$ is a jump process with rates $R(x_c,x_d,t)$. At each jump of $x_d$, a jump can also be added to the continuous variable $x_c$.\n\n\n\n\nInstallation\n\n\nTo install this (unregistered) package, run the command \n\n\nPkg.clone(\nhttps://github.com/rveltz/PDMP.jl.git\n)\n\n\n\n\n\n\nBasic example with CHV method\n\n\nA strong requirement for the CHV method is that the total rate (\ni.e.\n sum(rate)) must be positive. This can be easily achieved by adding a dummy Poisson process with very low intensity (see next section).\n\n\nSee also the \nexamples directory\n for more involved examples.\n\n\nA simple example of a TCP process is given below. More precisely, we look at the following process of switching dynamics where $X(t) = (x_c(t), x_d(t)) \\in\\mathbb R\\times\\lbrace-1,1\\rbrace.$ In between jumps, $x_c$ evolves according to $\\dot x_c(t) = x_d(t)x_c(t).$ \n\n\nWe first need to load the library.\n\n\nusing PDMP\n\n\n\n\nWe then define a function that encodes the dynamics in between jumps. We need to provide the vector field of the ODE with a function. Hence, we need to define a function that given continuous state $x_c$ and discrete state $x_d$ at time $t$ return the vector field. In addition some parameters can be passed with the variable \nparms\n.\n\n\nfunction F_tcp!(xcdot, xc, xd, t, parms)\n  # vector field used for the continuous variable\n  xcdot[1] = xd[1]*xc[1]\nend\n\n\n\n\nLet's consider a stochastic process with following transitions:\n\n\n\n\n\nx_d\\to x_d-2\n\n\n\n\n\nwith transition rate = 1 if $x_d\n0$\n\n\n\n\n\nx_d\\to x_d+2\n\n\n\n\n\nwith transition rate = 1 if $x_d\n0$\n\n\nor\n\n\n| Transition | Rate |  |\u2013-|\u2013-|\u2013-|  |$x_d\\to x_d-2$ if $x_d\n0$ | 1 |  |$x_d\\to x_d+2$ if $x_d\n0$ | 1 |\n\n\nThis is encoded in the following function\n\n\nfunction R_tcp!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd-\nxd+2 or xd-\nxd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  if sum_rate == false\n      if xd[1] \n 0\n          rate[1] = 0.\n          rate[2] = 1.\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0.\n  else\n    # we return sum(rate) without altering rate as we are asked to do\n    return 1.\n  end\nend\n\n# initial conditions for the continuous/discrete variables\nxc0 = vec([0.05])\nxd0 = vec([1])\n\n# matrix of jumps for the discrete variables, analogous to chemical reactions\nnu = reshape([[2];[-2]],2,1)\n\n\n# parameters\nparms = [0.]\ntf = 25.\n\n# compile the program:\ndummy =  PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=1)\n\n# compute a trajectory, in this case 100 jumps\nsrand(123)\nresult =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=100)\n\n# plotting\nusing Plots\nPlots.plot(result.time, result.xd[1,:],line=:step,title = string(\n#Jumps = \n,length(result.time)),label=\nXd\n)\nPlots.plot(result.time, result.xc',title = string(\n#Jumps = \n,length(result.time)),label=\nXc\n)\n\n\n\n\nThis produces the following graph:\n\n\n\n\n\n\nAdding more sampling points in between jumps\n\n\nThe current interface \"only\" returns the jumping times. On may want to resolve the trajectory in between jumps. For example, in the previous example, in between two jumps, the trajectory should be exponential and not linear as shown. \n\n\nA simple trick to do this is to add a Poisson process to the reactions set with a given sampling rate. We have to modify \nnu, xcd0\n and \nR_tcp!\n for this.\n\n\nnu2 = [[2 0];[-2 0];[0 1]]\n# the second component is the Poisson process\nxd0 = vec([1, 0])\n\nfunction R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd-\nxd+2 or xd-\nxd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  rate_save = 10. #sampling rate in between true jumps\n  if sum_rate == false\n      if xd[1] \n 0\n          rate[1] = 0.\n          rate[2] = 1.\n          rate[3] = rate_save #Poisson process used as sampling process\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n          rate[3] = rate_save #Poisson process used as sampling process\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0.\n  else\n    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so\n    return 1. + rate_save\n  end\nend\n\nsrand(123)\nresult2 =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000)\nPlots.plot(result2.time, result2.xc',title = string(\n#Jumps = \n,length(result2.time)),label=\nXc2\n)\n\n\n\n\nThis gives the following result:\n\n\n\n\n\n\nBasic example with the rejection method\n\n\nThe previous method is useful when the total rate function varies a lot. In the case where the total rate is mostly constant in between jumps, the \nrejection method\n is more appropriate. \n\n\nThe \nrejection method\n assumes some a priori knowledge of the process one wants to simulate. In particular, the user must be able to provide a bound on the total rate. More precisely, the user must provide a constant bound in between jump. To use this method, one needs to return \nsum(rate), bound_rejection\n in the above function \nR_tcp!\n. Note that this means that in between jumps, one have:\n\n\nsum(rate)(t) \n= bound_rejection\n\n\nnu2 = [[2 0];[-2 0];[0 1]]\n# the second component is the Poisson process\nxd0 = vec([1, 0])\n\nfunction R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd-\nxd+2 or xd-\nxd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  rate_save       = 10.           # sampling rate in between true jumps\n  bound_rejection = 1.+rate_save  # bound on the total rate, here 0 + 1 + rate_save\n  if sum_rate == false\n      if xd[1] \n 0\n          rate[1] = 0.\n          rate[2] = 1.\n          rate[3] = rate_save #Poisson process used as sampling process\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n          rate[3] = rate_save #Poisson process used as sampling process\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0., bound_rejection\n  else\n    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so\n    return 1. + rate_save, bound_rejection\n  end\nend\n\n\n\n\nWe can now simulate this process as follows\n\n\nsrand(123)\nresult3 =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000,algo=:rejection)\nPlots.plot(result3.time, result3.xc',title = string(\n#Jumps = \n,length(result3.time)),label=\nrejection\n)\n\n\n\n\n\n\nApplication programming interface\n\n\n\n\nFunctions\n\n\n#\n\n\nPDMP.pdmp!\n \n \nFunction\n.\n\n\nThis function performs a pdmp simulation using the Change of Variable (CHV, see https://arxiv.org/abs/1504.06873) method or the rejection method. It takes the following arguments:\n\n\n\n\nxc0\n: a \nVector\n of \nFloat64\n, representing the initial states of the continuous variable.\n\n\nxd0\n: a \nVector\n of \nInt64\n, representing the initial states of the discrete variable.\n\n\nF!\n: an inplace \nFunction\n or a callable type, which itself takes five arguments to represent the vector field; xdot a \nVector\n of \nFloat64\n representing the vector field associated to the continuous variable, xc \nVector\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time and parms, a \nVector\n of \nFloat64\n representing the parameters of the system. \nF!(xdot,xc,xd,t,parms)\n returns \nnothing\n\n\nR!\n: an inplace \nFunction\n or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate \nVector\n of \nFloat64\n holding the different reaction rates, xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and sum_rate a \nBool\n being a flag asking to return a \nFloat64\n if true and a \nVector\n otherwise. \nR!(rate,xc,xd,t,parms,sum_rate)\n returns \nFloat64,Float64\n\n\nDX\n: a \nFunction\n or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and ind_rec an \nInt64\n representing the index of the discrete jump. \nDX(xc,xd,t,parms,ind_rec)\n returns \nnothing\n\n\nnu\n: a \nMatrix\n of \nInt64\n, representing the transitions of the system, organised by row.\n\n\nparms\n : a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\ntf\n: the final simulation time (\nFloat64\n)\n\n\nverbose\n: a \nBool\n for printing verbose.\n\n\node\n: ode time stepper :cvode or :lsoda.\n\n\nn_jumps\n: an \nInt64\n representing the maximum number of jumps to be computed.\n\n\nind_save_d\n: a range to hold the indices of the discrete variable to be saved\n\n\nind_save_c\n: a range to hold the indices of the continuous variable to be saved\n\n\n\n\nsource\n\n\n#\n\n\nPDMP.chv!\n \n \nFunction\n.\n\n\nchv!\n\n\nThis function performs a pdmp simulation using the Change of Variable (CHV) method see https://arxiv.org/abs/1504.06873. It takes the following arguments:\n\n\n\n\nn_max\n: an \nInt64\n representing the maximum number of jumps to be computed.\n\n\nxc0\n : a \nVector\n of \nFloat64\n, representing the initial states of the continuous variable.\n\n\nxd0\n : a \nVector\n of \nInt64\n, representing the initial states of the discrete variable.\n\n\nF!\n : an inplace \nFunction\n or a callable type, which itself takes five arguments to represent the vector field; xdot a \nVector\n of \nFloat64\n representing the vector field associated to the continuous variable, xc \nVector\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time and parms, a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\nR\n : an inplace \nFunction\n or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate \nVector\n of \nFloat64\n holding the different reaction rates, xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and sum_rate a \nBool\n being a flag asking to return a \nFloat64\n if true and a \nVector\n otherwise.\n\n\nDX\n : a \nFunction\n or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and ind_rec an \nInt64\n representing the index of the discrete jump.\n\n\nnu\n : a \nMatrix\n of \nInt64\n, representing the transitions of the system, organised by row.\n\n\nparms\n : a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\ntf\n : the final simulation time (\nFloat64\n)\n\n\nverbose\n : a \nBool\n for printing verbose.\n\n\node\n: ode time stepper :cvode or :lsoda\n\n\n\n\nsource\n\n\n#\n\n\nPDMP.rejection_exact\n \n \nFunction\n.\n\n\nrejection_exact\n\n\nThis function performs a simulation using the rejection method when the flow \nis known analytically\n. It takes the following arguments:\n\n\n\n\nn_max\n: an \nInt64\n representing the maximum number of jumps to be computed.\n\n\nxc0\n : a \nVector\n of \nFloat64\n, representing the initial states of the continuous variable.\n\n\nxd0\n : a \nVector\n of \nInt64\n, representing the initial states of the discrete variable.\n\n\nPhi!\n : a \nFunction\n or a callable type, which itself takes 6 arguments to represent the vector field; rate a \nVector\n of \nFloat64\n representing the \nflow\n of the vector which needs to be filled with values of the rates, xdot a \nVector\n of \nFloat64\n representing the vector field associated to the continuous variable, xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time and parms, a \nVector\n of \nFloat64\n representing the parameters of the system, sum_of_rate a \nBool\n stating if the function must return the total rate.\n\n\nR!\n : a \nFunction\n or a callable type, which itself takes five arguments to represent the rate functions associated to the jumps;xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and sum_rate a \nBool\n being a flag asking to return a \nFloat64\n if true and a \nVector\n otherwise. The returned vector has components. If sum_rate is \nFalse\n, one must return rate_vector, bound_ where bound_ is a bound on the total rate vector. In the case sum_rate is \nTrue\n, one must return total_rate,bound_ where total_rate is a \nFloat64\n that is the sum of the rates. In any case, the function must return a couple (total_rates, bound) where bound is a bound for the total rate.\n\n\nDelta\n : a \nFunction\n or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc \nVector\n of \nFloat64\n representing the current state of the continuous variable, xd \nVector\n of \nInt64\n representing the current state of the discrete variable, t a \nFloat64\n representing the current time, parms a \nVector\n of \nFloat64\n representing the parameters of the system and ind_rec an \nInt64\n representing the index of the discrete jump.\n\n\nnu\n : a \nMatrix\n of \nInt64\n, representing the transitions of the system, organised by row.\n\n\nparms\n : a \nVector\n of \nFloat64\n representing the parameters of the system.\n\n\ntf\n : the final simulation time (\nFloat64\n)\n\n\nverbose\n : a \nBool\n for printing verbose.\n\n\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#pdmpjl", 
            "text": "PDMP.jl is a Julia package that allows simulation of  Piecewise Deterministic Markov Processes  (PDMP); these encompass hybrid systems and jump processes, comprised of continuous and discrete components, as well as processes with time-varying rates. The aim of the package is to provide methods for the simulation of these processes that are \"exact\" up to the ODE integrator.  We provide several methods for the simulation:   a recent trick, called  CHV , explained in  paper-2015  which allows to implement the  True Jump Method  without the need to use event detection schemes for the ODE integrator. These event detections can be quite unstable as explained in  paper-2015  and CHV provide a solution to this problem.  rejection methods  for which the user is asked to provide a bound on the reaction rates. These last methods are the most \"exact\" but not the fastest if the reaction rate bound is not tight. In case the flow is known analytically, a method is also provided.   These methods require solving stiff ODEs (for CHV ) in an efficient manner.  Sundials.jl  and  LSODA.jl  are used, but other solvers could be easily added. (See  stiff ode solvers ).  We briefly recall facts about a simple class of PDMPs. They are described by a couple $(x_c,x_d)$ where $x_c$ is solution of the differential equation $\\frac{dx_c}{dt} = F(x_c,x_d,t)$. The second component $x_d$ is a jump process with rates $R(x_c,x_d,t)$. At each jump of $x_d$, a jump can also be added to the continuous variable $x_c$.", 
            "title": "PDMP.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "To install this (unregistered) package, run the command   Pkg.clone( https://github.com/rveltz/PDMP.jl.git )", 
            "title": "Installation"
        }, 
        {
            "location": "/#basic-example-with-chv-method", 
            "text": "A strong requirement for the CHV method is that the total rate ( i.e.  sum(rate)) must be positive. This can be easily achieved by adding a dummy Poisson process with very low intensity (see next section).  See also the  examples directory  for more involved examples.  A simple example of a TCP process is given below. More precisely, we look at the following process of switching dynamics where $X(t) = (x_c(t), x_d(t)) \\in\\mathbb R\\times\\lbrace-1,1\\rbrace.$ In between jumps, $x_c$ evolves according to $\\dot x_c(t) = x_d(t)x_c(t).$   We first need to load the library.  using PDMP  We then define a function that encodes the dynamics in between jumps. We need to provide the vector field of the ODE with a function. Hence, we need to define a function that given continuous state $x_c$ and discrete state $x_d$ at time $t$ return the vector field. In addition some parameters can be passed with the variable  parms .  function F_tcp!(xcdot, xc, xd, t, parms)\n  # vector field used for the continuous variable\n  xcdot[1] = xd[1]*xc[1]\nend  Let's consider a stochastic process with following transitions:   \nx_d\\to x_d-2   with transition rate = 1 if $x_d 0$   \nx_d\\to x_d+2   with transition rate = 1 if $x_d 0$  or  | Transition | Rate |  |\u2013-|\u2013-|\u2013-|  |$x_d\\to x_d-2$ if $x_d 0$ | 1 |  |$x_d\\to x_d+2$ if $x_d 0$ | 1 |  This is encoded in the following function  function R_tcp!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd- xd+2 or xd- xd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  if sum_rate == false\n      if xd[1]   0\n          rate[1] = 0.\n          rate[2] = 1.\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0.\n  else\n    # we return sum(rate) without altering rate as we are asked to do\n    return 1.\n  end\nend\n\n# initial conditions for the continuous/discrete variables\nxc0 = vec([0.05])\nxd0 = vec([1])\n\n# matrix of jumps for the discrete variables, analogous to chemical reactions\nnu = reshape([[2];[-2]],2,1)\n\n\n# parameters\nparms = [0.]\ntf = 25.\n\n# compile the program:\ndummy =  PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=1)\n\n# compute a trajectory, in this case 100 jumps\nsrand(123)\nresult =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp!,nu,parms,0.0,tf,n_jumps=100)\n\n# plotting\nusing Plots\nPlots.plot(result.time, result.xd[1,:],line=:step,title = string( #Jumps =  ,length(result.time)),label= Xd )\nPlots.plot(result.time, result.xc',title = string( #Jumps =  ,length(result.time)),label= Xc )  This produces the following graph:", 
            "title": "Basic example with CHV method"
        }, 
        {
            "location": "/#adding-more-sampling-points-in-between-jumps", 
            "text": "The current interface \"only\" returns the jumping times. On may want to resolve the trajectory in between jumps. For example, in the previous example, in between two jumps, the trajectory should be exponential and not linear as shown.   A simple trick to do this is to add a Poisson process to the reactions set with a given sampling rate. We have to modify  nu, xcd0  and  R_tcp!  for this.  nu2 = [[2 0];[-2 0];[0 1]]\n# the second component is the Poisson process\nxd0 = vec([1, 0])\n\nfunction R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd- xd+2 or xd- xd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  rate_save = 10. #sampling rate in between true jumps\n  if sum_rate == false\n      if xd[1]   0\n          rate[1] = 0.\n          rate[2] = 1.\n          rate[3] = rate_save #Poisson process used as sampling process\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n          rate[3] = rate_save #Poisson process used as sampling process\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0.\n  else\n    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so\n    return 1. + rate_save\n  end\nend\n\nsrand(123)\nresult2 =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000)\nPlots.plot(result2.time, result2.xc',title = string( #Jumps =  ,length(result2.time)),label= Xc2 )  This gives the following result:", 
            "title": "Adding more sampling points in between jumps"
        }, 
        {
            "location": "/#basic-example-with-the-rejection-method", 
            "text": "The previous method is useful when the total rate function varies a lot. In the case where the total rate is mostly constant in between jumps, the  rejection method  is more appropriate.   The  rejection method  assumes some a priori knowledge of the process one wants to simulate. In particular, the user must be able to provide a bound on the total rate. More precisely, the user must provide a constant bound in between jump. To use this method, one needs to return  sum(rate), bound_rejection  in the above function  R_tcp! . Note that this means that in between jumps, one have:  sum(rate)(t)  = bound_rejection  nu2 = [[2 0];[-2 0];[0 1]]\n# the second component is the Poisson process\nxd0 = vec([1, 0])\n\nfunction R_tcp2!(rate, xc, xd, t, parms, sum_rate::Bool)\n  # transition rates function for each transition\n  # in this case,  the transitions are xd- xd+2 or xd- xd-2\n  # sum_rate is a boolean which tells R_tcp if it needs to return the total reaction rates, this may \n  # i.e. the sum of the rates or the vector of the rates\n  rate_save       = 10.           # sampling rate in between true jumps\n  bound_rejection = 1.+rate_save  # bound on the total rate, here 0 + 1 + rate_save\n  if sum_rate == false\n      if xd[1]   0\n          rate[1] = 0.\n          rate[2] = 1.\n          rate[3] = rate_save #Poisson process used as sampling process\n      else\n          rate[1] = 1.\n          rate[2] = 0.\n          rate[3] = rate_save #Poisson process used as sampling process\n      end\n      #we return 0. because nothing is supposed to be returned\n      return 0., bound_rejection\n  else\n    # we see that we effectively return sum(rate) without altering rate because it is not asked to do so\n    return 1. + rate_save, bound_rejection\n  end\nend  We can now simulate this process as follows  srand(123)\nresult3 =  @time PDMP.pdmp!(xc0,xd0,F_tcp!,R_tcp2!,nu2,parms,0.0,tf,n_jumps=10000,algo=:rejection)\nPlots.plot(result3.time, result3.xc',title = string( #Jumps =  ,length(result3.time)),label= rejection )", 
            "title": "Basic example with the rejection method"
        }, 
        {
            "location": "/#application-programming-interface", 
            "text": "", 
            "title": "Application programming interface"
        }, 
        {
            "location": "/#functions", 
            "text": "#  PDMP.pdmp!     Function .  This function performs a pdmp simulation using the Change of Variable (CHV, see https://arxiv.org/abs/1504.06873) method or the rejection method. It takes the following arguments:   xc0 : a  Vector  of  Float64 , representing the initial states of the continuous variable.  xd0 : a  Vector  of  Int64 , representing the initial states of the discrete variable.  F! : an inplace  Function  or a callable type, which itself takes five arguments to represent the vector field; xdot a  Vector  of  Float64  representing the vector field associated to the continuous variable, xc  Vector  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time and parms, a  Vector  of  Float64  representing the parameters of the system.  F!(xdot,xc,xd,t,parms)  returns  nothing  R! : an inplace  Function  or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate  Vector  of  Float64  holding the different reaction rates, xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and sum_rate a  Bool  being a flag asking to return a  Float64  if true and a  Vector  otherwise.  R!(rate,xc,xd,t,parms,sum_rate)  returns  Float64,Float64  DX : a  Function  or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and ind_rec an  Int64  representing the index of the discrete jump.  DX(xc,xd,t,parms,ind_rec)  returns  nothing  nu : a  Matrix  of  Int64 , representing the transitions of the system, organised by row.  parms  : a  Vector  of  Float64  representing the parameters of the system.  tf : the final simulation time ( Float64 )  verbose : a  Bool  for printing verbose.  ode : ode time stepper :cvode or :lsoda.  n_jumps : an  Int64  representing the maximum number of jumps to be computed.  ind_save_d : a range to hold the indices of the discrete variable to be saved  ind_save_c : a range to hold the indices of the continuous variable to be saved   source  #  PDMP.chv!     Function .  chv!  This function performs a pdmp simulation using the Change of Variable (CHV) method see https://arxiv.org/abs/1504.06873. It takes the following arguments:   n_max : an  Int64  representing the maximum number of jumps to be computed.  xc0  : a  Vector  of  Float64 , representing the initial states of the continuous variable.  xd0  : a  Vector  of  Int64 , representing the initial states of the discrete variable.  F!  : an inplace  Function  or a callable type, which itself takes five arguments to represent the vector field; xdot a  Vector  of  Float64  representing the vector field associated to the continuous variable, xc  Vector  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time and parms, a  Vector  of  Float64  representing the parameters of the system.  R  : an inplace  Function  or a callable type, which itself takes six arguments to represent the rate functions associated to the jumps;rate  Vector  of  Float64  holding the different reaction rates, xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and sum_rate a  Bool  being a flag asking to return a  Float64  if true and a  Vector  otherwise.  DX  : a  Function  or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and ind_rec an  Int64  representing the index of the discrete jump.  nu  : a  Matrix  of  Int64 , representing the transitions of the system, organised by row.  parms  : a  Vector  of  Float64  representing the parameters of the system.  tf  : the final simulation time ( Float64 )  verbose  : a  Bool  for printing verbose.  ode : ode time stepper :cvode or :lsoda   source  #  PDMP.rejection_exact     Function .  rejection_exact  This function performs a simulation using the rejection method when the flow  is known analytically . It takes the following arguments:   n_max : an  Int64  representing the maximum number of jumps to be computed.  xc0  : a  Vector  of  Float64 , representing the initial states of the continuous variable.  xd0  : a  Vector  of  Int64 , representing the initial states of the discrete variable.  Phi!  : a  Function  or a callable type, which itself takes 6 arguments to represent the vector field; rate a  Vector  of  Float64  representing the  flow  of the vector which needs to be filled with values of the rates, xdot a  Vector  of  Float64  representing the vector field associated to the continuous variable, xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time and parms, a  Vector  of  Float64  representing the parameters of the system, sum_of_rate a  Bool  stating if the function must return the total rate.  R!  : a  Function  or a callable type, which itself takes five arguments to represent the rate functions associated to the jumps;xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and sum_rate a  Bool  being a flag asking to return a  Float64  if true and a  Vector  otherwise. The returned vector has components. If sum_rate is  False , one must return rate_vector, bound_ where bound_ is a bound on the total rate vector. In the case sum_rate is  True , one must return total_rate,bound_ where total_rate is a  Float64  that is the sum of the rates. In any case, the function must return a couple (total_rates, bound) where bound is a bound for the total rate.  Delta  : a  Function  or a callable type, which itself takes five arguments to apply the jump to the continuous variable;xc  Vector  of  Float64  representing the current state of the continuous variable, xd  Vector  of  Int64  representing the current state of the discrete variable, t a  Float64  representing the current time, parms a  Vector  of  Float64  representing the parameters of the system and ind_rec an  Int64  representing the index of the discrete jump.  nu  : a  Matrix  of  Int64 , representing the transitions of the system, organised by row.  parms  : a  Vector  of  Float64  representing the parameters of the system.  tf  : the final simulation time ( Float64 )  verbose  : a  Bool  for printing verbose.   source", 
            "title": "Functions"
        }
    ]
}